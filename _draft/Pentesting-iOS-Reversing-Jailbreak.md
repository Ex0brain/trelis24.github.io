---
layout: post
title:  "iOS Pentesting Guide - Reversing Jailbreak"
categories: "iOS"
tags:  iOS pentest reversing
author: Trelis
---

* content
{:toc}

In this article jailbreak detection method is analyzed and bypassed doing reversing.



# Jailbreak
## Introduction
iOS jailbreaking is privilege escalation for the purpose of removing software restrictions imposed by Apple. It typically does this by using a series of kernel patches. Jailbreaking permits root access to iOS, allowing the downloading and installation of additional applications, extension, and themes that are unavailable through the official Apple App Store.

A lot of applications allow its execution in jailbroken devices, even though having jailbreak detection, because they don't want to lose users. For example, banks allow applications to execute in all devices but some fucntionalities might be restricted to be executed only in non-jailbroken devices.

## Detection
### File based detectoin
During the jailbreaking process, some additional files are created on the device. Looking for these files is a simple way to detect a jailbreak. It's also an easy method for a malicious individual to detect and bypass. An attacker can search for a string in the application, and then simply change the file names in question to avoid detection.


* Files or appplciations used
```
/private/var/lib/apt
/private/var/tmp/cydia.log
/private/var/lib/cydia
/private/var/mobile/Library/SBSettings/Themes
/Library/MobileSubstrate/MobileSubstrate.dylib
/Library/MobileSubstrate/DynamicLibraries/Veency.plist
/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist
/System/Library/LaunchDaemons/com.ikey.bbot.plist
/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist
/var/cache/apt
/var/lib/apt
/var/lib/cydia
/var/log/syslog
/var/tmp/cydia.log
/bin/bash
/bin/sh
/usr/sbin/sshd
/usr/libexec/ssh-keysign
/usr/sbin/sshd
/usr/bin/sshd
/usr/libexec/sftp-server
/etc/ssh/sshd_config
/etc/apt
/Applications/Cydia.app
/Applications/RockApp.app
/Applications/Icy.app
/Applications/WinterBoard.app
/Applications/SBSettings.app
/Applications/MxTube.app
/Applications/IntelliScreen.app
/Applications/FakeCarrier.app
/Applications/blackra1n.app
```

* Directory permissions
Like detecting a jailbroken device by looking for certain new files, certain permissions on partitions and folders can also indicate a jailbroken device.

During the jailbreaking process, access to the root partition is amended. If the root partition has read/write permissions, the device has been jailbroken.

* Size of /etc/fstab file
The /etc/fstab file contains mount points for the system. Many jailbreaking tools modify this file by adding entries to it, changing its file size. The typical iOS app isn't capable of reading the file, but it can check the size of the file.

Do note however, that the file size can change as a result of a new update from Apple.

* Existence of symbolic links
Some directories are originally located in the small system partition, however, this partition is overwritten during the jailbreak process. Therefore the data must be relocated to the larger data partition. Because the old file location must remain valid, symbolic links are created. The following list contains files/directories which would be symbolic links on a jailbroken device. An application could check for these symbolic links, and, if they exist, detect a jailbreak.
```
/Library/Ringtones
/Library/Wallpaper
/usr/arm-apple-darwin9
/usr/include
/usr/libexec
/usr/share
/Applications
```

* Writing files
On jailbroken devices, applications are installed the /Applications folder and thereby given root privileges. A jailbroken device could be detected by having the app check whether it can modify files outside of its sandbox. This can be done by having the app attempt to create a file in, for example, the /private directory. If the file is successfully created, the device has been jailbroken.

### API-based detection
Some API calls provided by iOS behave differently if run on jailbroken devices. Detecting a jailbroken device based on API calls can be both effective and difficult for a malicious individual to recognize and bypass.

* fork()
The sandbox denies process forking on non-jailbroken devices. By checking the returned pid on fork(), an app can detect if it has successfully forked. If the fork is successful, the app can deduce that it is running on a jailbroken device.

* system()
Calling the system() function with a NULL argument on a non-jailbroken device will return 0. Doing the same on a jailbroken device will return 1. This is because the function will check whether /bin/sh exists, and it only exists on jailbroken devices.

* dyld functions
This detection method starts with calling functions like _dyld_image_count() and _dyld_get_image_name() to see what dylibs are currently loaded. This method is very difficult to dynamically patch due to the fact that the patches themselves are part of dylibs.

### OpenSSH Service Detection
Jailbroken devices can run services that aren't normally present on non-jailbroken devices - the most common is the OpenSSH service.

Note that this detection method can be very slow. If SSH is not installed or running on the device, it can take some time for the connection to timeout. Attackers can also easily bypass this method by simply changing the port for the OpenSSH service.

### Cydia Scheme Detection
Most jailbroken devices have Cydia installed. While an attacker can change the location of the Cydia app, it's unlikely they will also change the URL scheme the Cydia app is registered with.

If calling the Cydia's URL scheme (cydia://) from your application is successful, you can be sure that the device is jailbroken.

It's difficult to change the scheme for Cydia, but it is possible to simply remove Cydia during the testing process.


## Reversing
For this article the function "jailbreakTest2Tapped" of the application "DVIA" has been used as an example.

The function starts with the following code:
[IMG1]

1. First of all obtain the object of the "NSFileManager" class (https://developer.apple.com/documentation/foundation/nsfilemanager) and save it in R6.
2. It saves the path "/Applications/Cydia.app" into R2.
3. Obtain the address of the function "fileExistsAtPath" (https://developer.apple.com/documentation/foundation/nsfilemanager/1415645-fileexistsatpath?language=objc) and saves into R1.
4. Finally it calls _objc_msgSend: (NSFileManager, fileExistsAtPath, /Applications/Cydia.app)
5. The method returns a boolean which is compared with 0xFF (R4). If the path or file exists, R4 will be 1 so it will jump to loc_1D46A (BNE = branch if not equal). However, if the path does not exist it will keep going doing more checks:

[IMG2]

The second check looks for the library "/Library/MobileSubstrate/MobileSubstrate.dylib". It uses the same procedure as before.
Loads the object of "NSFileManager" class and calls the function "fileExistsAtPath".
If the file exists it will jump to "loc_1D46A", otherwise it continues:

[IMG3]

The third check looks for the file "/bin/bash". It uses the same procedure as before. If the file exists it jumps to "loc_1D46A", otherwise it continues:

[IMG4]

The forth check looks for the file "/usr/sbin/sshd". It uses the same procedure as before. However, if the file exists it jumps to "loc_1D584" (BEQ = branch if equal), otherwise it continues. 


## Pseudo Code
  
      if ([[NSFileManager defaultManager] fileExistsAtPath:@"/Applications/Cydia.app"]){
          return YES;
        }else if([[NSFileManager defaultManager] fileExistsAtPath:@"/Library/MobileSubstrate/MobileSubstrate.dylib"]){
          return YES;
        }else if([[NSFileManager defaultManager] fileExistsAtPath:@"/bin/bash"]){
          return YES;
        }else if([[NSFileManager defaultManager] fileExistsAtPath:@"/usr/sbin/sshd"]){
          return YES;
        }else if([[NSFileManager defaultManager] fileExistsAtPath:@"/etc/apt"]){
          return YES;
        }
      return NO;
    }


    NSError *error;
    NSString *stringToBeWritten = @"This is a test.";
    [stringToBeWritten writeToFile:@"/private/jailbreak.txt" atomically:YES
             encoding:NSUTF8StringEncoding error:&error];
    if(error==nil){
       //Device is jailbroken
       return YES;
     } else {
       //Device is not jailbroken
       [[NSFileManager defaultManager] removeItemAtPath:@"/private/jailbreak.txt" error:nil];
     }


    if([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"cydia://package/com.example.package"]]){
      //Device is jailbroken
    }

    //All checks have failed. Most probably, the device is not jailbroken
    return NO;

## Patching
