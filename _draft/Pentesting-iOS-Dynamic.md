---
layout: post
title:  "iOS Pentesting Guide (Static analysis)"
categories: "iOS"
tags:  iOS pentest
author: Trelis
---

* content
{:toc}

A summary of all the commands and things I do during an iOS application static analysis.




# General commands
## Application directory 
An iOS application has two main folders where it saves the data. The static data is saved in the /Applications o /private/var/mobile/Applications folder depending on if the app is Native or downloaded via AppStore respectively.

The complete path can be obtained with the following command:
```
ps aux | grep -i AppName
```

The dynamic data in /var/mobile/Containers/Data/Application/ folder. The application saves data used in runtime.

The complete path can be obtained with cycript with the following command:
```
cycript -p AppPID

[[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
```

## Search text in files
During the analysis, it is important to always search for sensible information in order to identify data leakage. 

To find any text inside files in a path recursively, the following command can be used:
```
grep -rnw '/path/to/somewhere/' -e 'pattern'
```

Moreover, it can be interesting to look for internals IPs, emails, credit card numbers... It can be done using regex:
```
IP (999.999.999.999)
\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b

IP2
\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.
  (25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.
  (25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.
  (25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b

Email Addresses
b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b

Credit Card Numbers
Visa: ^4[0-9]{12}(?:[0-9]{3})?$ 
MasterCard: ^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$ 
American Express: ^3[47][0-9]{13}$
Diners Club: ^3(?:0[0-5]|[68][0-9])[0-9]{11}$ 
Discover: ^6(?:011|5[0-9]{2})[0-9]{12}$
JCB: ^(?:2131|1800|35\d{3})\d{11}$

Combination:
^(?:4[0-9]{12}(?:[0-9]{3})?          # Visa
 |  (?:5[1-5][0-9]{2}                # MasterCard
     | 222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}
 |  3[47][0-9]{13}                   # American Express
 |  3(?:0[0-5]|[68][0-9])[0-9]{11}   # Diners Club
 |  6(?:011|5[0-9]{2})[0-9]{12}      # Discover
 |  (?:2131|1800|35\d{3})\d{11}      # JCB
)$

```
* More information: https://www.regular-expressions.info/ip.html

You can use these regex with the following command:
```
grep -E 'REGEX' -r *
```

## Search files by name
There are several files which have to be taken into account in order to detect sensible data disclosure:
* .plist
* .sql
* .db
* .xml

The command find looks for files by name. Wildcard (*) can be used to search files by extension:
```
find . -iname "*PATTERN*"
```

## Read plist
With the following command can be used to read plist files:
```
plutil FILE.plist | less
```

However, it can be converted to XML if you want to modify some data or save it in a readable format:
```
plutil -convert xml1 Info.plist -o output

plutil -convert plist Info.xml -o output
```


# Insecure Data Storage
## Insecure storage
There are a lot of applications which save sensible information unencrypted in insecure databases like:
* plist
* xml
* db
* sql
* localstorage

All this files should be checked before and after the test due to sometimes the information is saved when the user do actions.

## NSUserDefaults
One of the most common ways of saving user preferences and properties in an application is by using NSUserDefaults. The information stored in NSUserDefaults persists even if you close the application and start it again. 
Usually it is used by the application to save default values like the user settings. It has to be taken into account that this class does not encrypt the data.

The plist can be found in the dynamic data folder:
```
/var/mobile/Containers/Data/Application/XXXXXXXX/Library/Preferences/$AppBundleId.plist
```

The name of $AppBundleId.plist can be found in the static data folder:
```
/var/mobile/Containers/Data/Application/XXXXX/XXX/Info.plist
```

## Keychain
It is a sqlite database located at /private/var/Keychains/keychain-2.db

It is possible to read the database data using Keychain Dumper: https://github.com/ptoomey3/Keychain-Dumper


There are different permissions type:
			NSFileProtectionComplete: accessible quan està desbloquejat (requereix pin de l'usuari). Important que els arxius tinguin aquesta opció, ja que sinó al fer backups a l'iCloud i iTunes es possible accedir a l'informació sensible.
			kSecAtrAccessibleAfterFirstUnlock: accessible quan es desbloqueja per primera vegada
			kSecAttrAccessibleAlways: sempre accessible
			kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly: accessible quan el móbil està desbloquejat i s'ha introduit el passcode

No sensible data should be saved in the keychain. In should be saved in the server.

During the test, the keychain should be checked with the mobile locked and unlocked and with the app stopeed and running. 

## Core Data (Ztables)
In the dynamic data folder there is a file called Cache.db. The application usually saves some data inside like HTTP requests and response, user data... It is highly recommended to check this database because the application might save sensible data like username or passwords. 

In order to read the database, sqlite3 must be used:
```
Coredata.sqlite
.tables
select * from TABLE
```

## Webkit Caching
An application which uses UIWebView might save sensible cache information in a table called "cf_url"


# iOS implementations Insecurities
## Keyboard
If the application does not implement their own keyboard, some sensitive information typed might be saved in the following files:
```
DATA/Library/Keyboard/dynamic-text.dat 

/var/mobile//Library/Keyboard/dynamic-text.dat	   
```

## Pasteboard Leakage
The application should not allow to copy any sensitive information like usernames, passwords, emails... This information is stored in the following file:
```
/private/var/mobile/Library/Caches/com.apple.UIKit.pboard
```

It can also be viewed with cycript:
```
[UIPasteboard generalPasteboard].items
```

## Snapshots
When the application goes in backgroud, the mobile takes a photo of the current screen in order to be used as a miniature when the user lists all the applications running.

It is recommended to configure the application because when minimized it uses a personalized photo in order to avoid sensitive information to be stored.

Snapshots are saved in the following folder:
```
/DATA/Library/Caches/Snapshots
```

## Cookies
The application saves the cookies used in the following folder:
```
DATA/Library/Cookies/
```

The file can be correctly view using the script BinaryCookieReader.py: https://github.com/as0ler/BinaryCookieReader

## Device Logging
common.cy:
```
@import com.saurik.substrate.MS
NSLog_ = dlsym(RTLD_DEFAULT, "NSLog")
NSLog = function() { var types = 'v', args = [], count = arguments.length; for (var i = 0; i != count; ++i) { types += '@'; args.push(arguments[i]); } new Functor(NSLog_, types).apply(null, args); }
```
Load file into cycript:
```
cycript -p MyApp-QA common.cy
cycript -p MyApp-QA
```
Read system log:
```
socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
watch
```


# Binary analyzer
## Dynamic dependences
```
otool -L app
```

## Dump the load commands for the application
```
otool -I app
```

## Position Independent Executable (PIE)
It is a security functionality which allows the application to use ASLR. The app must be compiled using the flag -fPIE -pie

With the following command it can be checked whether the PIE is active or not:
```
otool -hv app
```

## Stack Smashing Protections
IT is a security functionality which loads a known value into the stack just before loading the application variables. This allows to protect the pointer 
		Permet carregar un valor conegut a l'stack abans de carregar les variables d'aplicació. D'aquesta manera és possible detectar i protegir els punters claus i arguments de funcions contra buffers overflows.
		otool -I -v app | grep stack
			stack_chk_fail
			stack_chk_guard
	Automatic Reference Countig (ARC)
		Fa que el compilador gestioni la memòria reduïnt així la possibilitat de que l'aplicació provoqui corrupció de memòria.
		otool -I -v app | grep _objc_
			_objc_retain
			_objc_release
			_objc_storeStrong
			_objc_releaseReturnValue
			_objc_autoreleaseReturnValue
			_objc_retainAutoreleaseReturnValue
	Decrypting iOS Binaries
		otool -arch all -Vl app | grep -A5 LC_ENCRYPT
		Clutch -i -> llista
		Clutch -b id
		Pot ser que surti un error a l'utiltizar clutch si l'aplicació depén d'altres binaris que usen un sistema d'encriptació diferent. Si és així, es poden eliminar, desxifrar l'aplicació i tornar-los a afegir. Sinó s'ha de reinstalar la app.
	Class dump
		Permet obtenir les classes i atributs de l'aplicació

Cycript
	Ver objetos del webview:
		UIApp.keyWindow .recursiveDescription().toString()
	Para acceder a objetos individuales i navegar por los distintos paneles del webview:
		UIApp.windows[0].subviews()[0].subviews()
	Seleccionar un botón:
		var button = UIAppWindows[0].subviews()[0].subviews()[4]
	Para ver la función que usa el objeto:
		var target = button.allTargets().allObjects()[0]
	Para ver la función a la que llama el botón:
		[button actionsForTarget:target forControlEvent:UIControlEventTouchUpInside]
	Seleccinar/veure contingut de les variables:
		target.<nom_variable>
	Llamar funciones
		[target <function>:<atributo>]
	Root view controller
		UIApp.KeyWindows.rootViewController